<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clean HTML Tool</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      max-width: 900px;
    }
    textarea {
      width: 100%;
      height: 300px;
      margin-bottom: 10px;
      font-family: monospace;
      white-space: pre-wrap;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>HTML Cleaner</h1>
  <p>Paste your HTML below, then click <strong>Clean HTML</strong>.</p>
  <textarea id="inputHtml" placeholder="Paste raw HTML here..."></textarea>
  <button onclick="cleanContent()">Clean HTML</button>
  <h2>Output</h2>
  <textarea id="outputHtml" readonly></textarea>

  <script>
    function cleanContent() {
      let html = document.getElementById("inputHtml").value;

      // Remove unwanted wrappers: all <div> and <section> tags completely
      html = html.replace(/<\s*(div|section)[^>]*>/gi, '');
      html = html.replace(/<\s*\/\s*(div|section)\s*>/gi, '');

      // Remove inline styles, classes, ids, and data-* attributes
      html = html.replace(/\s*(style|class|id|data-[^\s=]+)="[^"]*"/gi, '');

      // Replace empty links with <u>
      html = html.replace(/<a\s+href=["']{0,1}["']{0,1}[^>]*>(.*?)<\/a>/gi, '<u>$1</u>');

      // Keep only href attribute in <a> tags
      html = html.replace(/<a\s+([^>]*?)>/gi, function(_, attrs) {
        const hrefMatch = attrs.match(/href\s*=\s*["'][^"']+["']/i);
        const href = hrefMatch ? hrefMatch[0] : '';
        return `<a ${href}>`;
      });

      // Fix headings: remove (hX) and keep content inside same tag
      html = html.replace(/<h([1-6])[^>]*>\(h\1\)\s*(.*?)<\/h\1>/gi, (_, level, content) => {
        return `<h${level}>${content.trim()}</h${level}>`;
      });

      // Remove any empty attributes left behind
      html = html.replace(/\s+\w+=""/g, '');

      // Format block elements: put opening and closing tags on the same line
      // and separate blocks by a blank line for readability
      
      // List of block tags to process
      const blockTags = ['h1','h2','h3','h4','h5','h6','p','ul','li','a','u','b','i'];

      // Parse the HTML into a DOM parser for safe manipulation
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      function serializeNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          return node.textContent.trim();
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
          let tag = node.tagName.toLowerCase();
          if (blockTags.includes(tag)) {
            let innerHTML = Array.from(node.childNodes).map(serializeNode).join('');
            return `<${tag}>${innerHTML}</${tag}>`;
          } else {
            // For other elements, just serialize innerHTML recursively
            return Array.from(node.childNodes).map(serializeNode).join('');
          }
        }
        return '';
      }

      // Serialize body children into formatted text
      let outputLines = [];
      doc.body.childNodes.forEach(child => {
        const tag = child.tagName ? child.tagName.toLowerCase() : '';
        if (blockTags.includes(tag)) {
          outputLines.push(serializeNode(child));
        } else if (child.nodeType === Node.TEXT_NODE) {
          if (child.textContent.trim()) {
            outputLines.push(child.textContent.trim());
          }
        } else {
          // For any other nodes, flatten their children
          outputLines.push(Array.from(child.childNodes).map(serializeNode).join(''));
        }
      });

      // Join with double newline for block spacing
      let finalHtml = outputLines.filter(line => line.trim() !== '').join('\n\n');

      document.getElementById("outputHtml").value = finalHtml;
    }
  </script>
</body>
</html>
